
int TIME_FRAME = 100;
int CLOCK_PIN = 6;
int DATA_PIN = 5;

int dataFrame[8];         // Array to store the 8 bits
int bitIndex = 0;

bool receiving = false;   // Flag to indicate if we are currently receiving data

// Timing thresholds (in microseconds)
const unsigned long LONG_PULSE_MIN = TIME_FRAME * 4;  // Minimum duration for the long pulse (5x normal pulse)
const unsigned long SHORT_PULSE_MAX = TIME_FRAME; // Maximum duration for a normal pulse

unsigned long clockHighStart = 0;
bool lastClockState = LOW;

void setup() {
  Serial.begin(9600);
  pinMode(CLOCK_PIN, INPUT);
  pinMode(DATA_PIN, INPUT);
}

void loop() {
  bool clockState = digitalRead(CLOCK_PIN);

  // Detect rising edge of clock
  if (lastClockState == LOW && clockState == HIGH) {
    unsigned long pulseDuration = micros() - clockHighStart;

    if (!receiving) {
      // Not receiving yet - check if this is the call sign (long pulse)
      // Note: The call sign is a long HIGH pulse followed by a short LOW pulse.
      // We measure the duration of the previous HIGH pulse here.
      if (pulseDuration >= LONG_PULSE_MIN) {
        // Detected call sign start
        Serial.println("Call sign detected. Starting data reception...");
        receiving = true;
        bitIndex = 0;
      }
    } else {
      // Receiving data - read DATA line on rising edge of clock
      if (bitIndex < 8) {
        int bitValue = digitalRead(DATA_PIN);
        dataFrame[bitIndex] = bitValue;
        bitIndex++;

        Serial.print("Received bit ");
        Serial.print(bitIndex);
        Serial.print(": ");
        Serial.println(bitValue);

        if (bitIndex == 8) {
          // Data frame complete
          Serial.print("Data frame received: ");
          for (int i = 0; i < 8; i++) {
            Serial.print(dataFrame[i]);
          }
          Serial.println();

          // Reset to wait for next transmission
          receiving = false;
        }
      }
    }
    // Reset the clockHighStart to measure next HIGH pulse duration
    clockHighStart = micros();
  }

  // Detect falling edge of clock to measure HIGH pulse duration
  if (lastClockState == HIGH && clockState == LOW) {
    clockHighStart = micros();
  }

  lastClockState = clockState;
}